---
title:词法作用域-函数作用域-块作用域
---

# 词法作用域-函数作用域-块作用域

作用域分类：**词法作用域**，动态作用域

### 词法作用域：
词法阶段，写代码时就已经决定好的（**函数被声明时的位置决定**）,父子作用域间要严格包含。

---

### 查找：作用域查找会在找到第一个匹配的标识符时停止。
遮蔽效应：读到内部作用域的相应标识符则停止查找，忽略了外部的同名标识符。

全局变量会自动成为全局对象的属性
```
通过全局对象属性访问全局变量a： window.a
```

---

### eval
定义：eval(...)函数，接受一个字符串为参数，将内容视为‘书写态即执行态’。

作用：执行动态创建的代码。严格模式下其中的声明无法修改所在作用域。

相似且过时的动态插入：（好像在面试题里见过）
setTimeout(...) 的第一个参数、setInterval(...)的第一个参数、 new Function()的最后一个参数。
同样作用：with：本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。（不建议使
用，且严格模式禁用）

**eval和with大量使用会影响运行速度。**

---

### 函数中的作用域
属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。

最小特权原则（最小授权或最小暴露原则）：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来。

故产生思路：利用函数作用域包装私有变量或函数。
缺点：
1.函数名本身被污染 
2.需要显式调用函数 

**规避冲突：**
```
function foo() {
  function bar(a) {
    i = 3; // 修改for 循环所属作用域中的i ； 这个i会出去找外部作用域的i
  //var i = 3 这样写就可以新声明一个变量 （遮蔽）
  //var j = 3 或者干脆换一个变量来用
    console.log( a + i );
  }
  for (var i=0; i<10; i++) {
  bar( i * 2 ); // 糟糕，无限循环了！
 }
}
foo(); //陷入死循环
```

**全局命名空间**
在全局声明一个名字独特的变量（通常是**对象**） ---> 命名空间

其暴露的功能就是对象的属性。

**函数声明**：function关键字出现在声明中的第一个词。foo绑定在所在作用域中。不可匿名。
**函数表达式**：function不是第一个词。foo绑定在函数表达式自身的函数中。可匿名。
```
(function foo(){ ... })  //作为函数表达式，foo只能在 ... 代表的位置被访问
```
最佳实践：行内函数表达式
setTimeout( function timeoutHandler() { // <-- 快看，我有名字了！
    console.log( "I waited 1 second!" );
}, 1000 );

**立即执行函数表达式 IIFE**
``` 
(function foo(){ .. })()  
(function(){ .. }())   //二者一致，全凭喜好
```
**块作用域**
try/catch 也会创建一个块作用域 -- catch内部有效。
let、const也会创建块作用域。

**let关键字**
可以将变量隐式地声明在所在的块作用域。